
1. What is Terraform and how does it fit in a DevOps pipeline?**

Answer:
Terraform is an open-source Infrastructure as Code (IaC) tool developed by HashiCorp used to provision and manage infrastructure across cloud providers (AWS, GCP, Azure, etc.). It allows you to define infrastructure declaratively using HCL (HashiCorp Configuration Language) and ensures idempotent, version-controlled, auditable, and repeatable deployments**.

In a DevOps pipeline:**

Plan phase**: Validate infra code before deployment.
Apply phase**: Provision infra during CD phase.
Destroy phase**: Clean up after tests or environments.

It integrates well with tools like Jenkins, GitHub Actions, Terraform Cloud/Enterprise, and is often used alongside Ansible, Packer, and Docker for full-stack provisioning.

2. Explain Terraform lifecycle and its phases.

Answer:
Terraform lifecycle consists of the following:

1. Init**: Initializes a working directory.
2. Validate: Validates the configuration files.
3. Plan: Shows execution plan — what will be created, destroyed, or changed.
4. Apply: Executes the actions proposed in the plan.
5. Destroy: Destroys all resources defined in the config.
6. Refresh: Updates the state file with real infrastructure.
7. Import: Brings existing infrastructure under Terraform management.

---

3. How do you structure Terraform code for a large-scale enterprise application?

Answer:
For a scalable, maintainable design:

Use modules for reusable components (VPC, EC2, RDS, etc.).
Follow directory structure:

  ```
  ├── environments/
  │   ├── dev/
  │   ├── prod/
  ├── modules/
  │   ├── vpc/
  │   ├── ec2/
  ├── main.tf
  ├── variables.tf
  ├── outputs.tf
  ├── terraform.tfvars
  ```
Use workspaces or separate backends for isolation.
Use remote backends (S3 + DynamoDB) to store state safely.
Implement Terraform Cloud/Enterprise** or Atlantis for collaboration and automation.

4. How do you manage secrets in Terraform?**

Answer:
Best practices include:

Avoid hardcoding secrets in `.tf` files.
Use Terraform variables** sourced from:

Encrypted `.tfvars` files (not ideal for high-security).
AWS Secrets Manager, SSM Parameter Store**, Vault.
Environment variables (e.g., `TF_VAR_secret`).
Use sensitive = true** to hide variable values in CLI outputs.
Use external data sources with Vault for dynamic secrets.

---

5. Explain Terraform state. Why is it important?

Answer:
Terraform state (`terraform.tfstate`) tracks the mapping between Terraform resources and real-world infrastructure. It is critical because:

Keeps track of resource metadata.
Enables plan/apply to work correctly.
Supports idempotency.
Allows drift detection.

For team use:

Store state in S3 with DynamoDB for state locking**.
Enable encryption at rest and versioning.

6. How do you handle drift detection and remediation?

Answer:
Drift occurs when real-world infrastructure differs from state file.

Steps:

Run `terraform plan` or `terraform refresh` to detect drift.
To remediate:

Use `terraform apply` to realign resources.
Or manually fix the infrastructure and `terraform import`.

For production, use tools like:

Driftctl or Terraform Cloud drift detection**
Set up alerts when changes are made outside Terraform.

7. How do you manage Terraform across multiple environments (Dev, QA, Prod)?

Answer:
Options:

Directory separation**:

   ```
   environments/dev/main.tf
   environments/prod/main.tf
   ```
Workspaces (good for small projects): `terraform workspace new dev`
Backend configuration per environment** using `terraform.tfvars`
CI/CD tools to manage environment-specific pipelines.

Enterprise scale: Use Terragrunt for DRY configuration and environment inheritance.

8. What is Terragrunt? Why and how do you use it?**

Answer:
Terragrunt is a thin wrapper for Terraform that provides:

DRY configuration (reduce repetition).
Built-in support for managing remote state.
Dependency management (resource orchestration).
Multiple environments support.

Sample `terragrunt.hcl`:

```hcl
include {
  path = find_in_parent_folders()
}

terraform {
  source = "../modules/vpc"
}

inputs = {
  region = "us-east-1"
}
```
9. How do you enforce compliance and security policies in Terraform?

Answer:
Tools:

Sentinel (HashiCorp Enterprise): Policy-as-code engine.
OPA + Conftest: Open Policy Agent for validating HCL.
Checkov, TFSec, Infracost: Scan for misconfigurations.

Policies may include:

Enforce encryption on S3 buckets.
Disallow public subnets or open security groups.
Limit instance types to cost-effective choices.

---

10. Describe a real-world production issue involving Terraform and how you resolved it.**

Answer (example):
*Issue:* Developer accidentally ran `terraform apply` on `main` instead of the `dev` branch and updated production infra (e.g., updated RDS parameters and caused downtime).

*Resolution:*

Rolled back using versioned state in S3.
Locked the state to prevent concurrent updates.
Implemented RBAC in Terraform Cloud with separate workspaces.
Added policy checks in CI to restrict changes on `main` to approvers only.
Introduced review process with `terraform plan` summary in pull requests.

---

11. How do you test Terraform code?
Answer:
terraform validate**: Syntax and config validation.
terraform plan**: Ensure expected changes.
unit testing**: Use `terraform-compliance` or `opa`.
Integration testing:
Spin up test infrastructure.
Use tools like Kitchen-Terraform, Terratest (Go).
Use CI/CD pipelines to enforce tests before `apply`.

---

12. What are Terraform Providers and how do you manage custom providers?**

Answer:
Providers are plugins that let Terraform interact with APIs (e.g., AWS, GCP, Datadog).

For custom providers:

Build in Go.
Publish to Terraform Registry or private registry.
Define source in configuration:

```hcl
terraform {
  required_providers {
    myprovider = {
      source  = "mycompany/myprovider"
      version = "1.0.0"
    }
  }
}
```
13. How do you manage Terraform module versions and dependencies?**

Answer:

* Pin versions using `version = ">= 1.0.0, < 2.0.0"` in `required_providers`.
* Store modules in:

  * Terraform Registry
  * GitHub/GitLab (with version tags)
  * Local files (not ideal for teams)
* Use `terraform get -update=true` to pull updated modules.


14. What is the difference between `count` and `for_each` in Terraform?

| Feature    | `count`                       | `for_each`                                 |
| ---------- | ----------------------------- | ------------------------------------------ |
| Use case   | Simple, identical resources   | Complex, keyed resources                   |
| Indexing   | Numeric index (`count.index`) | Key-value pairs (`each.key`, `each.value`) |
| Limitation | Cannot destroy selectively    | Can manage resources individually          |


15. How do you ensure idempotency in Terraform?

Answer:
Terraform is inherently idempotent:

Tracks state, only applies changes when config diverges from real infra.
To maintain idempotency:
Avoid external/manual changes.
Use `terraform plan` before `apply`.
Lock state during concurrent changes.
Use version control and proper CI/CD enforcement.


